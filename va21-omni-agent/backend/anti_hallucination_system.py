"""
VA21 Anti-Hallucination System - Comprehensive AI Accuracy Framework

This module provides a robust anti-hallucination system that uses:
- Unique IDs with timestamps
- Version history correlation
- Obsidian Knowledge Vault integration
- Mind map visualization
- Cross-validation checks
"""

import uuid
import hashlib
import json
import os
import time
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass, field
from enum import Enum
import threading


class ValidationLevel(Enum):
    """Validation strictness levels."""
    BASIC = "basic"           # Just check existence
    STANDARD = "standard"     # Check ID + timestamp
    STRICT = "strict"         # Check ID + timestamp + checksum
    PARANOID = "paranoid"     # Full cross-validation with history


@dataclass
class TimestampedID:
    """
    Unique identifier with embedded timestamp for anti-hallucination.
    
    Format: {type}_{date}_{time}_{random}_{checksum}
    Example: backup_20241202_081500_a1b2c3d4_f9e8d7c6
    """
    uid: str                  # Full unique ID
    short_id: str            # 8-char display ID
    component_type: str      # Type of component
    created_timestamp: datetime
    created_timestamp_unix: float  # Unix timestamp for precision
    random_part: str         # Random component
    checksum: str            # Validation checksum
    sequence_number: int     # Global sequence for ordering
    
    def to_dict(self) -> Dict:
        return {
            'uid': self.uid,
            'short_id': self.short_id,
            'component_type': self.component_type,
            'created_timestamp': self.created_timestamp.isoformat(),
            'created_timestamp_unix': self.created_timestamp_unix,
            'random_part': self.random_part,
            'checksum': self.checksum,
            'sequence_number': self.sequence_number
        }
    
    @classmethod
    def from_dict(cls, data: Dict) -> 'TimestampedID':
        return cls(
            uid=data['uid'],
            short_id=data['short_id'],
            component_type=data['component_type'],
            created_timestamp=datetime.fromisoformat(data['created_timestamp']),
            created_timestamp_unix=data['created_timestamp_unix'],
            random_part=data['random_part'],
            checksum=data['checksum'],
            sequence_number=data['sequence_number']
        )
    
    def validate_format(self) -> bool:
        """Validate the ID format is correct."""
        try:
            parts = self.uid.split('_')
            if len(parts) < 5:
                return False
            
            # Validate date format
            date_part = parts[1]
            datetime.strptime(date_part, '%Y%m%d')
            
            # Validate time format
            time_part = parts[2]
            datetime.strptime(time_part, '%H%M%S')
            
            return True
        except:
            return False
    
    def recalculate_checksum(self) -> str:
        """Recalculate checksum for validation."""
        data = f"{self.component_type}{self.created_timestamp_unix}{self.random_part}{self.sequence_number}"
        return hashlib.sha256(data.encode()).hexdigest()[:8]
    
    def is_checksum_valid(self) -> bool:
        """Check if checksum matches."""
        return self.checksum == self.recalculate_checksum()


@dataclass
class ValidationResult:
    """Result of a validation check."""
    is_valid: bool
    validation_level: ValidationLevel
    checks_passed: List[str]
    checks_failed: List[str]
    confidence_score: float  # 0.0 to 1.0
    details: Dict
    timestamp: datetime
    
    def to_obsidian_note(self) -> str:
        """Generate Obsidian note content."""
        status = "✅ VALID" if self.is_valid else "❌ INVALID"
        
        content = f"""# Validation Result - {status}

## Summary
- **Confidence Score**: {self.confidence_score * 100:.1f}%
- **Validation Level**: {self.validation_level.value}
- **Timestamp**: {self.timestamp.isoformat()}

## Checks Passed
{chr(10).join('- ✅ ' + c for c in self.checks_passed) if self.checks_passed else '- None'}

## Checks Failed
{chr(10).join('- ❌ ' + c for c in self.checks_failed) if self.checks_failed else '- None'}

## Details
```json
{json.dumps(self.details, indent=2)}
```

---
Generated by VA21 Anti-Hallucination System
"""
        return content


class AntiHallucinationSystem:
    """
    VA21 Anti-Hallucination System - Prevents AI from making up information.
    
    Features:
    - Timestamped unique IDs for all components
    - Cross-validation with version history
    - Obsidian Knowledge Vault integration
    - Mind map for visual verification
    - Multiple validation levels
    - Confidence scoring
    """
    
    # Global sequence counter
    _sequence_counter = 0
    _sequence_lock = threading.Lock()
    
    def __init__(self, data_dir: str = "data/anti_hallucination",
                 obsidian_vault: str = "data/research_vault"):
        self.data_dir = data_dir
        self.obsidian_vault = obsidian_vault
        self.registry_file = os.path.join(data_dir, "id_registry.json")
        self.validation_log = os.path.join(data_dir, "validation_log.json")
        self.mind_map_file = os.path.join(obsidian_vault, "VA21_Mind_Map.md")
        
        # ID Registry - all generated IDs
        self.id_registry: Dict[str, TimestampedID] = {}
        
        # Validation cache
        self.validation_cache: Dict[str, ValidationResult] = {}
        self.cache_ttl = 300  # 5 minutes
        
        # Cross-reference maps
        self.type_to_ids: Dict[str, List[str]] = {}
        self.date_to_ids: Dict[str, List[str]] = {}
        self.sequence_to_id: Dict[int, str] = {}
        
        # Statistics
        self.stats = {
            'ids_generated': 0,
            'validations_performed': 0,
            'validations_passed': 0,
            'validations_failed': 0,
            'hallucinations_detected': 0
        }
        
        self._initialize()
    
    def _initialize(self):
        """Initialize the anti-hallucination system."""
        os.makedirs(self.data_dir, exist_ok=True)
        os.makedirs(os.path.join(self.obsidian_vault, "anti_hallucination"), exist_ok=True)
        self._load_registry()
        self._update_mind_map()
    
    def _load_registry(self):
        """Load ID registry from disk."""
        if os.path.exists(self.registry_file):
            try:
                with open(self.registry_file, 'r') as f:
                    data = json.load(f)
                    for uid, id_data in data.get('ids', {}).items():
                        tid = TimestampedID.from_dict(id_data)
                        self.id_registry[uid] = tid
                        self._update_indexes(tid)
                    
                    # Restore sequence counter
                    AntiHallucinationSystem._sequence_counter = data.get('sequence', 0)
                    self.stats = data.get('stats', self.stats)
            except Exception as e:
                print(f"[AntiHallucination] Error loading registry: {e}")
    
    def _save_registry(self):
        """Save ID registry to disk."""
        try:
            data = {
                'ids': {uid: tid.to_dict() for uid, tid in self.id_registry.items()},
                'sequence': AntiHallucinationSystem._sequence_counter,
                'stats': self.stats,
                'saved_at': datetime.now().isoformat()
            }
            with open(self.registry_file, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            print(f"[AntiHallucination] Error saving registry: {e}")
    
    def _update_indexes(self, tid: TimestampedID):
        """Update cross-reference indexes."""
        # Type index
        if tid.component_type not in self.type_to_ids:
            self.type_to_ids[tid.component_type] = []
        if tid.uid not in self.type_to_ids[tid.component_type]:
            self.type_to_ids[tid.component_type].append(tid.uid)
        
        # Date index
        date_key = tid.created_timestamp.strftime('%Y-%m-%d')
        if date_key not in self.date_to_ids:
            self.date_to_ids[date_key] = []
        if tid.uid not in self.date_to_ids[date_key]:
            self.date_to_ids[date_key].append(tid.uid)
        
        # Sequence index
        self.sequence_to_id[tid.sequence_number] = tid.uid
    
    # ==================== ID GENERATION ====================
    
    def generate_id(self, component_type: str, 
                   metadata: Dict = None) -> TimestampedID:
        """
        Generate a unique timestamped ID that cannot be hallucinated.
        
        The ID format includes:
        - Component type
        - Date (YYYYMMDD)
        - Time (HHMMSS)
        - Random component (8 chars)
        - Checksum (8 chars)
        """
        now = datetime.now()
        unix_timestamp = time.time()
        
        # Get sequence number atomically
        with AntiHallucinationSystem._sequence_lock:
            AntiHallucinationSystem._sequence_counter += 1
            sequence = AntiHallucinationSystem._sequence_counter
        
        # Generate random component
        random_part = uuid.uuid4().hex[:8]
        
        # Generate checksum
        checksum_data = f"{component_type}{unix_timestamp}{random_part}{sequence}"
        checksum = hashlib.sha256(checksum_data.encode()).hexdigest()[:8]
        
        # Build full UID
        date_str = now.strftime('%Y%m%d')
        time_str = now.strftime('%H%M%S')
        uid = f"{component_type}_{date_str}_{time_str}_{random_part}_{checksum}"
        short_id = f"{random_part[:4]}{checksum[:4]}".upper()
        
        tid = TimestampedID(
            uid=uid,
            short_id=short_id,
            component_type=component_type,
            created_timestamp=now,
            created_timestamp_unix=unix_timestamp,
            random_part=random_part,
            checksum=checksum,
            sequence_number=sequence
        )
        
        # Register
        self.id_registry[uid] = tid
        self._update_indexes(tid)
        self.stats['ids_generated'] += 1
        
        # Create Obsidian note
        self._create_id_note(tid, metadata)
        
        # Save
        self._save_registry()
        
        return tid
    
    def _create_id_note(self, tid: TimestampedID, metadata: Dict = None):
        """Create an Obsidian note for the ID."""
        note_path = os.path.join(
            self.obsidian_vault, 
            "anti_hallucination",
            f"{tid.short_id}_{tid.component_type}.md"
        )
        
        content = f"""# {tid.component_type.title()} - {tid.short_id}

## Identification
- **Full ID**: `{tid.uid}`
- **Short ID**: `{tid.short_id}`
- **Type**: {tid.component_type}
- **Sequence**: #{tid.sequence_number}

## Timestamps
- **Created**: {tid.created_timestamp.isoformat()}
- **Unix Timestamp**: {tid.created_timestamp_unix}
- **Date**: {tid.created_timestamp.strftime('%Y-%m-%d')}
- **Time**: {tid.created_timestamp.strftime('%H:%M:%S')}

## Validation
- **Random Part**: `{tid.random_part}`
- **Checksum**: `{tid.checksum}`
- **Format Valid**: {'✅ Yes' if tid.validate_format() else '❌ No'}
- **Checksum Valid**: {'✅ Yes' if tid.is_checksum_valid() else '❌ No'}

## Metadata
```json
{json.dumps(metadata or {}, indent=2)}
```

## Links
- [[VA21_Mind_Map]]
- [[{tid.component_type}_index|{tid.component_type.title()} Index]]

---
*Generated by VA21 Anti-Hallucination System*
*Sequence: #{tid.sequence_number} | Checksum: {tid.checksum}*
"""
        
        try:
            with open(note_path, 'w') as f:
                f.write(content)
        except Exception as e:
            print(f"[AntiHallucination] Error creating note: {e}")
    
    # ==================== VALIDATION ====================
    
    def validate(self, uid: str, 
                level: ValidationLevel = ValidationLevel.STANDARD,
                expected_type: str = None,
                expected_timestamp: datetime = None,
                tolerance_seconds: int = 60) -> ValidationResult:
        """
        Validate an ID to prevent hallucinations.
        
        Args:
            uid: The ID to validate
            level: Validation strictness level
            expected_type: Expected component type
            expected_timestamp: Expected creation time
            tolerance_seconds: Allowed time difference
        
        Returns:
            ValidationResult with detailed information
        """
        self.stats['validations_performed'] += 1
        
        checks_passed = []
        checks_failed = []
        details = {}
        
        # Check cache first
        cache_key = f"{uid}_{level.value}"
        if cache_key in self.validation_cache:
            cached = self.validation_cache[cache_key]
            if (datetime.now() - cached.timestamp).total_seconds() < self.cache_ttl:
                return cached
        
        # Check existence
        if uid not in self.id_registry:
            checks_failed.append("ID not found in registry")
            self.stats['validations_failed'] += 1
            self.stats['hallucinations_detected'] += 1
            
            result = ValidationResult(
                is_valid=False,
                validation_level=level,
                checks_passed=checks_passed,
                checks_failed=checks_failed,
                confidence_score=0.0,
                details={'error': 'ID not registered - possible hallucination'},
                timestamp=datetime.now()
            )
            
            self._log_hallucination(uid, result)
            return result
        
        checks_passed.append("ID exists in registry")
        tid = self.id_registry[uid]
        details['component_type'] = tid.component_type
        details['created'] = tid.created_timestamp.isoformat()
        
        # BASIC level - just existence
        if level == ValidationLevel.BASIC:
            self.stats['validations_passed'] += 1
            return ValidationResult(
                is_valid=True,
                validation_level=level,
                checks_passed=checks_passed,
                checks_failed=checks_failed,
                confidence_score=0.7,
                details=details,
                timestamp=datetime.now()
            )
        
        # STANDARD level - check format and timestamp
        if tid.validate_format():
            checks_passed.append("ID format is valid")
        else:
            checks_failed.append("ID format is invalid")
        
        if expected_type and tid.component_type != expected_type:
            checks_failed.append(f"Type mismatch: expected {expected_type}, got {tid.component_type}")
        elif expected_type:
            checks_passed.append("Component type matches")
        
        if expected_timestamp:
            diff = abs((tid.created_timestamp - expected_timestamp).total_seconds())
            if diff <= tolerance_seconds:
                checks_passed.append(f"Timestamp within tolerance ({diff:.1f}s)")
            else:
                checks_failed.append(f"Timestamp outside tolerance ({diff:.1f}s > {tolerance_seconds}s)")
        
        if level == ValidationLevel.STANDARD:
            is_valid = len(checks_failed) == 0
            confidence = 0.85 if is_valid else 0.3
            
            if is_valid:
                self.stats['validations_passed'] += 1
            else:
                self.stats['validations_failed'] += 1
            
            result = ValidationResult(
                is_valid=is_valid,
                validation_level=level,
                checks_passed=checks_passed,
                checks_failed=checks_failed,
                confidence_score=confidence,
                details=details,
                timestamp=datetime.now()
            )
            self.validation_cache[cache_key] = result
            return result
        
        # STRICT level - verify checksum
        if tid.is_checksum_valid():
            checks_passed.append("Checksum verification passed")
        else:
            checks_failed.append("Checksum verification failed - possible tampering")
            self.stats['hallucinations_detected'] += 1
        
        if level == ValidationLevel.STRICT:
            is_valid = len(checks_failed) == 0
            confidence = 0.95 if is_valid else 0.1
            
            if is_valid:
                self.stats['validations_passed'] += 1
            else:
                self.stats['validations_failed'] += 1
            
            result = ValidationResult(
                is_valid=is_valid,
                validation_level=level,
                checks_passed=checks_passed,
                checks_failed=checks_failed,
                confidence_score=confidence,
                details=details,
                timestamp=datetime.now()
            )
            self.validation_cache[cache_key] = result
            return result
        
        # PARANOID level - cross-validate with all sources
        # Check sequence ordering
        if tid.sequence_number in self.sequence_to_id:
            if self.sequence_to_id[tid.sequence_number] == uid:
                checks_passed.append("Sequence number verified")
            else:
                checks_failed.append("Sequence number conflict detected")
        
        # Check date index
        date_key = tid.created_timestamp.strftime('%Y-%m-%d')
        if date_key in self.date_to_ids and uid in self.date_to_ids[date_key]:
            checks_passed.append("Date index verified")
        else:
            checks_failed.append("Date index mismatch")
        
        # Check type index
        if tid.component_type in self.type_to_ids and uid in self.type_to_ids[tid.component_type]:
            checks_passed.append("Type index verified")
        else:
            checks_failed.append("Type index mismatch")
        
        # Check Obsidian note exists
        note_path = os.path.join(
            self.obsidian_vault,
            "anti_hallucination",
            f"{tid.short_id}_{tid.component_type}.md"
        )
        if os.path.exists(note_path):
            checks_passed.append("Obsidian note exists")
        else:
            checks_failed.append("Obsidian note missing")
        
        is_valid = len(checks_failed) == 0
        confidence = 0.99 if is_valid else 0.05
        
        if is_valid:
            self.stats['validations_passed'] += 1
        else:
            self.stats['validations_failed'] += 1
            self.stats['hallucinations_detected'] += 1
        
        result = ValidationResult(
            is_valid=is_valid,
            validation_level=level,
            checks_passed=checks_passed,
            checks_failed=checks_failed,
            confidence_score=confidence,
            details=details,
            timestamp=datetime.now()
        )
        
        self.validation_cache[cache_key] = result
        
        if not is_valid:
            self._log_hallucination(uid, result)
        
        return result
    
    def _log_hallucination(self, uid: str, result: ValidationResult):
        """Log a detected hallucination."""
        log_entry = {
            'uid': uid,
            'detected_at': datetime.now().isoformat(),
            'validation_level': result.validation_level.value,
            'checks_failed': result.checks_failed,
            'confidence_score': result.confidence_score
        }
        
        # Append to log file
        try:
            log_data = []
            if os.path.exists(self.validation_log):
                with open(self.validation_log, 'r') as f:
                    log_data = json.load(f)
            
            log_data.append(log_entry)
            
            # Keep last 1000 entries
            log_data = log_data[-1000:]
            
            with open(self.validation_log, 'w') as f:
                json.dump(log_data, f, indent=2)
        except Exception as e:
            print(f"[AntiHallucination] Error logging: {e}")
        
        # Create Obsidian alert
        self._create_hallucination_alert(uid, result)
    
    def _create_hallucination_alert(self, uid: str, result: ValidationResult):
        """Create an Obsidian alert for hallucination."""
        alert_path = os.path.join(
            self.obsidian_vault,
            "anti_hallucination",
            f"ALERT_{datetime.now().strftime('%Y%m%d_%H%M%S')}.md"
        )
        
        content = f"""# ⚠️ HALLUCINATION ALERT

## Detected Invalid ID
- **UID**: `{uid}`
- **Detected At**: {datetime.now().isoformat()}
- **Confidence**: {result.confidence_score * 100:.1f}%

## Failed Checks
{chr(10).join('- ❌ ' + c for c in result.checks_failed)}

## Action Required
This ID was not found in the registry or failed validation.
The AI may have hallucinated this identifier.

## Recommendations
1. Verify the source of this ID
2. Check if the component actually exists
3. Re-generate the ID if needed

---
*VA21 Anti-Hallucination System Alert*
"""
        
        try:
            with open(alert_path, 'w') as f:
                f.write(content)
        except Exception as e:
            print(f"[AntiHallucination] Error creating alert: {e}")
    
    # ==================== MIND MAP ====================
    
    def _update_mind_map(self):
        """Update the Obsidian mind map."""
        # Group IDs by type and date
        type_groups = {}
        for uid, tid in self.id_registry.items():
            if tid.component_type not in type_groups:
                type_groups[tid.component_type] = []
            type_groups[tid.component_type].append(tid)
        
        content = f"""# VA21 Anti-Hallucination Mind Map

> **Last Updated**: {datetime.now().isoformat()}
> **Total IDs**: {len(self.id_registry)}
> **Sequence**: #{AntiHallucinationSystem._sequence_counter}

## System Overview

```mermaid
mindmap
  root((VA21 System))
    Anti-Hallucination
      ID Registry
      Validation
      Mind Map
    Components
"""
        
        # Add component types to mermaid
        for comp_type, tids in type_groups.items():
            content += f"      {comp_type.title()}\n"
            for tid in tids[-5:]:  # Last 5 per type
                content += f"        {tid.short_id}\n"
        
        content += """```

## Component Index

"""
        
        # Add component sections
        for comp_type, tids in type_groups.items():
            content += f"""### {comp_type.title()} ({len(tids)} items)

| Short ID | Full ID | Created | Sequence |
|----------|---------|---------|----------|
"""
            for tid in sorted(tids, key=lambda t: t.sequence_number, reverse=True)[:10]:
                content += f"| [[{tid.short_id}_{comp_type}|{tid.short_id}]] | `{tid.uid[:30]}...` | {tid.created_timestamp.strftime('%Y-%m-%d %H:%M')} | #{tid.sequence_number} |\n"
            
            content += "\n"
        
        content += f"""
## Statistics

- **IDs Generated**: {self.stats['ids_generated']}
- **Validations Performed**: {self.stats['validations_performed']}
- **Validations Passed**: {self.stats['validations_passed']}
- **Validations Failed**: {self.stats['validations_failed']}
- **Hallucinations Detected**: {self.stats['hallucinations_detected']}

## Validation Status

{'✅ System Healthy' if self.stats['hallucinations_detected'] == 0 else f"⚠️ {self.stats['hallucinations_detected']} Hallucinations Detected"}

---
*Generated by VA21 Anti-Hallucination System*
"""
        
        try:
            with open(self.mind_map_file, 'w') as f:
                f.write(content)
        except Exception as e:
            print(f"[AntiHallucination] Error updating mind map: {e}")
    
    # ==================== UTILITIES ====================
    
    def get_id_by_short(self, short_id: str) -> Optional[TimestampedID]:
        """Get full ID by short ID."""
        for tid in self.id_registry.values():
            if tid.short_id == short_id.upper():
                return tid
        return None
    
    def get_ids_by_type(self, component_type: str) -> List[TimestampedID]:
        """Get all IDs of a specific type."""
        if component_type not in self.type_to_ids:
            return []
        return [self.id_registry[uid] for uid in self.type_to_ids[component_type]]
    
    def get_ids_by_date(self, date: datetime) -> List[TimestampedID]:
        """Get all IDs created on a specific date."""
        date_key = date.strftime('%Y-%m-%d')
        if date_key not in self.date_to_ids:
            return []
        return [self.id_registry[uid] for uid in self.date_to_ids[date_key]]
    
    def get_recent_ids(self, count: int = 20) -> List[TimestampedID]:
        """Get most recently created IDs."""
        sorted_ids = sorted(
            self.id_registry.values(),
            key=lambda t: t.sequence_number,
            reverse=True
        )
        return sorted_ids[:count]
    
    def get_stats(self) -> Dict:
        """Get anti-hallucination system statistics."""
        return {
            **self.stats,
            'total_ids': len(self.id_registry),
            'current_sequence': AntiHallucinationSystem._sequence_counter,
            'component_types': list(self.type_to_ids.keys()),
            'cache_size': len(self.validation_cache),
            'validation_success_rate': (
                self.stats['validations_passed'] / max(self.stats['validations_performed'], 1)
            ) * 100
        }
    
    def clear_cache(self):
        """Clear validation cache."""
        self.validation_cache.clear()
    
    def export_for_ai(self) -> Dict:
        """Export data for AI consumption with anti-hallucination markers."""
        return {
            'export_id': self.generate_id('export').uid,
            'export_timestamp': datetime.now().isoformat(),
            'total_components': len(self.id_registry),
            'component_types': {
                ctype: len(ids) for ctype, ids in self.type_to_ids.items()
            },
            'recent_ids': [
                {
                    'short_id': tid.short_id,
                    'type': tid.component_type,
                    'created': tid.created_timestamp.isoformat(),
                    'checksum': tid.checksum
                }
                for tid in self.get_recent_ids(10)
            ],
            'validation_instructions': (
                "Always validate IDs before using them. "
                "Use the validate() method with appropriate level. "
                "Never assume an ID exists - verify first."
            )
        }


# Singleton
_anti_hallucination: Optional[AntiHallucinationSystem] = None


def get_anti_hallucination_system() -> AntiHallucinationSystem:
    """Get the singleton Anti-Hallucination System instance."""
    global _anti_hallucination
    if _anti_hallucination is None:
        _anti_hallucination = AntiHallucinationSystem()
    return _anti_hallucination
